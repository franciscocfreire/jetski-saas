{
  "info": {
    "_postman_id": "jetski-saas-api-v1",
    "name": "Jetski SaaS API",
    "description": "Collection para testes manuais da API Jetski SaaS multi-tenant.\n\n## Configuração Inicial\n\n1. Importe os 4 ambientes (local, dev, hml, prd) disponíveis na pasta `postman/environments/`\n2. Selecione o ambiente desejado no dropdown do Postman\n3. Execute o request \"Get Access Token\" para obter o JWT\n4. O token será automaticamente salvo na variável `access_token` do ambiente\n5. Todos os requests protegidos usarão automaticamente este token\n\n## Multi-tenancy\n\nTodos os endpoints (exceto públicos e autenticação) requerem:\n- **Authorization**: Bearer token JWT\n- **X-Tenant-Id**: UUID do tenant (configurado na variável `tenant_id` do ambiente)\n\n## Estrutura\n\n- **Auth**: Obtenção de tokens JWT via Keycloak\n- **User**: Gerenciamento de usuários e listagem de tenants\n- **User Invitation**: Convidar e ativar usuários (fluxo OIDC completo)\n- **Auth Tests**: Endpoints de teste para validação de segurança (RBAC, OPA)\n- **Health**: Health checks e métricas\n\n## User Invitation Flow (OIDC)\n\n**Novo fluxo com Keycloak OIDC:**\n1. ADMIN_TENANT convida usuário → gera token (48h)\n2. Usuário ativa conta (sem senha) → criado no Keycloak com required action UPDATE_PASSWORD\n3. Email enviado com link de login\n4. Usuário faz login → Keycloak solicita definição de senha\n5. Usuário define senha e está autenticado!\n\nVer documentação completa: `backend/OIDC_ACTIVATION_FLOW.md`\n\n## Infraestrutura\n\n**OPA (Open Policy Agent):** v1.9.0  \nPolicies modernizadas com sintaxe Rego v1 (upgrade em 2025-10-20)\n\n## Versionamento\n\nEsta collection é **viva** e será atualizada conforme novos endpoints forem adicionados.\n\nVersão: 1.2.1\nÚltima atualização: 2025-10-20",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
    "_exporter_id": "jetski-team"
  },
  "item": [
    {
      "name": "Auth",
      "description": "Endpoints de autenticação via Keycloak OAuth2/OIDC",
      "item": [
        {
          "name": "Get Access Token",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "// Salva o access_token na variável de ambiente",
                  "if (pm.response.code === 200) {",
                  "    const jsonData = pm.response.json();",
                  "    pm.environment.set(\"access_token\", jsonData.access_token);",
                  "    pm.environment.set(\"refresh_token\", jsonData.refresh_token);",
                  "    pm.environment.set(\"token_expires_in\", jsonData.expires_in);",
                  "    ",
                  "    console.log(\"✅ Access token obtido com sucesso!\");",
                  "    console.log(\"Expira em:\", jsonData.expires_in, \"segundos\");",
                  "} else {",
                  "    console.error(\"❌ Erro ao obter token:\", pm.response.text());",
                  "}"
                ],
                "type": "text/javascript"
              }
            },
            {
              "listen": "prerequest",
              "script": {
                "exec": [
                  "// Validação de variáveis necessárias",
                  "const requiredVars = [\"keycloak_url\", \"keycloak_realm\", \"client_id\", \"client_secret\", \"username\", \"password\"];",
                  "const missing = requiredVars.filter(v => !pm.environment.get(v));",
                  "",
                  "if (missing.length > 0) {",
                  "    console.error(\"❌ Variáveis de ambiente ausentes:\", missing);",
                  "    throw new Error(\"Configure as variáveis: \" + missing.join(\", \"));",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/x-www-form-urlencoded",
                "type": "text"
              }
            ],
            "body": {
              "mode": "urlencoded",
              "urlencoded": [
                {
                  "key": "grant_type",
                  "value": "password",
                  "type": "text"
                },
                {
                  "key": "client_id",
                  "value": "{{client_id}}",
                  "type": "text"
                },
                {
                  "key": "client_secret",
                  "value": "{{client_secret}}",
                  "type": "text"
                },
                {
                  "key": "username",
                  "value": "{{username}}",
                  "type": "text"
                },
                {
                  "key": "password",
                  "value": "{{password}}",
                  "type": "text"
                },
                {
                  "key": "scope",
                  "value": "openid profile email",
                  "type": "text"
                }
              ]
            },
            "url": {
              "raw": "{{keycloak_url}}/realms/{{keycloak_realm}}/protocol/openid-connect/token",
              "host": [
                "{{keycloak_url}}"
              ],
              "path": [
                "realms",
                "{{keycloak_realm}}",
                "protocol",
                "openid-connect",
                "token"
              ]
            },
            "description": "Obtém um access token JWT do Keycloak usando Resource Owner Password Credentials.\n\n**Variáveis necessárias:**\n- `keycloak_url`: URL base do Keycloak\n- `keycloak_realm`: Nome do realm\n- `client_id`: Client ID configurado no Keycloak\n- `client_secret`: Client secret (confidential client)\n- `username`: Usuário para login\n- `password`: Senha do usuário\n\n**Resposta:**\nO token JWT será salvo automaticamente na variável `access_token`."
          },
          "response": []
        },
        {
          "name": "Refresh Token",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "if (pm.response.code === 200) {",
                  "    const jsonData = pm.response.json();",
                  "    pm.environment.set(\"access_token\", jsonData.access_token);",
                  "    pm.environment.set(\"refresh_token\", jsonData.refresh_token);",
                  "    pm.environment.set(\"token_expires_in\", jsonData.expires_in);",
                  "    console.log(\"✅ Token renovado com sucesso!\");",
                  "} else {",
                  "    console.error(\"❌ Erro ao renovar token:\", pm.response.text());",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/x-www-form-urlencoded"
              }
            ],
            "body": {
              "mode": "urlencoded",
              "urlencoded": [
                {
                  "key": "grant_type",
                  "value": "refresh_token",
                  "type": "text"
                },
                {
                  "key": "client_id",
                  "value": "{{client_id}}",
                  "type": "text"
                },
                {
                  "key": "client_secret",
                  "value": "{{client_secret}}",
                  "type": "text"
                },
                {
                  "key": "refresh_token",
                  "value": "{{refresh_token}}",
                  "type": "text"
                }
              ]
            },
            "url": {
              "raw": "{{keycloak_url}}/realms/{{keycloak_realm}}/protocol/openid-connect/token",
              "host": [
                "{{keycloak_url}}"
              ],
              "path": [
                "realms",
                "{{keycloak_realm}}",
                "protocol",
                "openid-connect",
                "token"
              ]
            },
            "description": "Renova o access token usando o refresh token.\n\nUse quando o access token expirar (geralmente após 5-15 minutos)."
          },
          "response": []
        }
      ]
    },
    {
      "name": "User",
      "description": "Endpoints relacionados a usuários e tenants",
      "item": [
        {
          "name": "List User Tenants",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 200\", function () {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"Response has access_type\", function () {",
                  "    const jsonData = pm.response.json();",
                  "    pm.expect(jsonData).to.have.property(\"access_type\");",
                  "    pm.expect(jsonData.access_type).to.be.oneOf([\"LIMITED\", \"UNRESTRICTED\"]);",
                  "});",
                  "",
                  "pm.test(\"If LIMITED, should have tenants array\", function () {",
                  "    const jsonData = pm.response.json();",
                  "    if (jsonData.access_type === \"LIMITED\") {",
                  "        pm.expect(jsonData).to.have.property(\"tenants\");",
                  "        pm.expect(jsonData.tenants).to.be.an(\"array\");",
                  "        pm.expect(jsonData).to.have.property(\"total_count\");",
                  "    }",
                  "});",
                  "",
                  "// Salva o primeiro tenant_id para uso em outros requests",
                  "const jsonData = pm.response.json();",
                  "if (jsonData.access_type === \"LIMITED\" && jsonData.tenants && jsonData.tenants.length > 0) {",
                  "    const firstTenantId = jsonData.tenants[0].tenant.id;",
                  "    pm.environment.set(\"tenant_id\", firstTenantId);",
                  "    console.log(\"✅ Primeiro tenant_id salvo:\", firstTenantId);",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "auth": {
              "type": "bearer",
              "bearer": [
                {
                  "key": "token",
                  "value": "{{access_token}}",
                  "type": "string"
                }
              ]
            },
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{api_url}}/v1/user/tenants",
              "host": [
                "{{api_url}}"
              ],
              "path": [
                "v1",
                "user",
                "tenants"
              ]
            },
            "description": "Lista todos os tenants que o usuário autenticado pode acessar.\n\n**Tipos de resposta:**\n- `LIMITED`: Retorna lista de tenants (máx 100)\n- `UNRESTRICTED`: Usuário é admin de plataforma, pode acessar qualquer tenant\n\n**Uso:**\n- Mobile app: Exibir seletor de tenant no login\n- Web app: Exibir dropdown de tenants"
          },
          "response": []
        }
      ]
    },
    {
      "name": "User Invitation",
      "description": "Endpoints para convidar e ativar usuários no tenant.\n\n**Fluxo Option 2 (Temporary Password):**\n1. ADMIN_TENANT convida usuário → backend gera senha temporária aleatória (12 chars)\n2. Backend armazena hash BCrypt da senha temporária\n3. Email enviado com token + senha temporária em texto plano\n4. Usuário ativa conta com token + senha temporária (endpoint público)\n5. Backend valida senha temporária contra hash BCrypt\n6. Cria usuário no PostgreSQL + Keycloak com senha temporária + required action UPDATE_PASSWORD\n7. Usuário faz primeiro login com senha temporária\n8. Keycloak FORÇA troca de senha (políticas gerenciadas pelo Keycloak)\n9. Usuário define senha permanente e está autenticado!",
      "item": [
        {
          "name": "Invite User to Tenant",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 200\", function () {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"Response has conviteId\", function () {",
                  "    const jsonData = pm.response.json();",
                  "    pm.expect(jsonData).to.have.property(\"conviteId\");",
                  "    pm.expect(jsonData).to.have.property(\"email\");",
                  "    pm.expect(jsonData).to.have.property(\"expiresAt\");",
                  "});",
                  "",
                  "// Salva dados para teste de ativação",
                  "const jsonData = pm.response.json();",
                  "if (jsonData.conviteId) {",
                  "    // Token não é retornado na API (só via email), mas podemos buscar no DB para testes",
                  "    console.log(\"✅ Convite criado:\", jsonData.conviteId);",
                  "    console.log(\"   Email:\", jsonData.email);",
                  "    console.log(\"   Expira em:\", jsonData.expiresAt);",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "auth": {
              "type": "bearer",
              "bearer": [
                {
                  "key": "token",
                  "value": "{{access_token}}",
                  "type": "string"
                }
              ]
            },
            "method": "POST",
            "header": [
              {
                "key": "X-Tenant-Id",
                "value": "{{tenant_id}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"email\": \"operador.novo@example.com\",\n  \"nome\": \"Operador Novo\",\n  \"papeis\": [\"OPERADOR\"]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{api_url}}/v1/tenants/{{tenant_id}}/users/invite",
              "host": [
                "{{api_url}}"
              ],
              "path": [
                "v1",
                "tenants",
                "{{tenant_id}}",
                "users",
                "invite"
              ]
            },
            "description": "Convida um novo usuário para o tenant.\n\n**Requer:** ADMIN_TENANT ou GERENTE role\n\n**Validações:**\n- Limite de usuários do plano não atingido\n- Email não possui convite pendente\n- Email não é membro do tenant\n\n**Resposta:**\n- Convite criado com token válido por 48h\n- Email de convite enviado (TODO)\n\n**Body:**\n```json\n{\n  \"email\": \"novo.usuario@example.com\",\n  \"nome\": \"Novo Usuário\",\n  \"papeis\": [\"OPERADOR\", \"VENDEDOR\"]\n}\n```\n\n**Roles disponíveis:**\n- ADMIN_TENANT\n- GERENTE\n- OPERADOR\n- VENDEDOR\n- MECANICO\n- FINANCEIRO"
          },
          "response": []
        }
      ]
    },
    {
      "name": "User Invitation (Single-Email Flow)",
      "description": "FLUXO OPTION 2: Ativação com senha temporária em um único email.\n\n**Fluxo Completo:**\n1. ADMIN_TENANT convida usuário → backend gera senha temporária aleatória (12 chars)\n2. Backend armazena hash BCrypt da senha temporária no BD\n3. Email enviado com: link de ativação + senha temporária em texto plano\n   - Link: /activate?token=xxx\n   - Senha temporária: Ab12#Xy9@Kl4 (exemplo)\n4. Usuário acessa formulário de ativação e informa: token + senha temporária do email\n5. POST /v1/auth/complete-activation (token + temporaryPassword)\n6. Backend valida senha temporária contra hash BCrypt\n7. Se válido: cria usuário no PostgreSQL + Keycloak com senha temporária + required action UPDATE_PASSWORD\n8. Usuário faz primeiro login com senha temporária\n9. Keycloak FORÇA troca de senha (políticas gerenciadas pelo Keycloak: comprimento, complexidade, histórico)\n10. Usuário define senha permanente e está autenticado!\n\n**Vantagens:**\n- UX simplificado: 1 único email\n- Segurança: senha temporária aleatória gerada pelo backend\n- Keycloak gerencia políticas de senha (não o frontend/backend)\n- Forçar troca no primeiro login garante senha conhecida apenas pelo usuário",
      "item": [
        {
          "name": "1. Invite User to Tenant",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 200\", function () {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"Response has conviteId\", function () {",
                  "    const jsonData = pm.response.json();",
                  "    pm.expect(jsonData).to.have.property(\"conviteId\");",
                  "    pm.expect(jsonData).to.have.property(\"email\");",
                  "    pm.expect(jsonData).to.have.property(\"expiresAt\");",
                  "});",
                  "",
                  "// Salva email para próximos testes",
                  "const jsonData = pm.response.json();",
                  "if (jsonData.email) {",
                  "    pm.environment.set(\"invited_email\", jsonData.email);",
                  "    console.log(\"✅ Convite criado (Option 2):\", jsonData.conviteId);",
                  "    console.log(\"   Email:\", jsonData.email);",
                  "    console.log(\"   Expira em:\", jsonData.expiresAt);",
                  "    console.log(\"\");",
                  "    console.log(\"🔔 IMPORTANTE: Busque token E senha temporária no email\");",
                  "    console.log(\"   Local: /tmp/emails/ (arquivo mais recente)\");",
                  "    console.log(\"   Token: na URL do link de ativação\");",
                  "    console.log(\"   Senha temporária: no corpo do email (12 chars aleatórios)\");",
                  "    console.log(\"   Ou via SQL: SELECT token FROM convite WHERE email = '\" + jsonData.email + \"' AND status = 'PENDING';\");",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "auth": {
              "type": "bearer",
              "bearer": [
                {
                  "key": "token",
                  "value": "{{access_token}}",
                  "type": "string"
                }
              ]
            },
            "method": "POST",
            "header": [
              {
                "key": "X-Tenant-Id",
                "value": "{{tenant_id}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"email\": \"teste.fluxo.unico@example.com\",\n  \"nome\": \"Teste Fluxo Único\",\n  \"papeis\": [\"OPERADOR\"]\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{api_url}}/v1/tenants/{{tenant_id}}/users/invite",
              "host": [
                "{{api_url}}"
              ],
              "path": [
                "v1",
                "tenants",
                "{{tenant_id}}",
                "users",
                "invite"
              ]
            },
            "description": "**Passo 1:** Convida usuário para o tenant (Option 2 flow).\n\n**Requer:** ADMIN_TENANT ou GERENTE\n\n**Ação:**\n- Email de convite enviado para `teste.fluxo.unico@example.com`\n- Email contém:\n  - Link de ativação: `{{frontend_url}}/activate?token=xxx`\n  - Senha temporária aleatória gerada pelo backend (12 chars)\n- Token válido por 48 horas\n\n**Backend (Option 2):**\n- Gera senha temporária aleatória: `SecureRandom` (12 chars)\n- Armazena hash BCrypt no campo `temporary_password_hash`\n- Envia senha temporária em texto plano NO EMAIL (única vez)\n\n**Próximos passos:**\n1. Verifique o email em `/tmp/emails/` (último arquivo criado)\n2. Copie o token da URL\n3. Copie a senha temporária do corpo do email\n4. Cole ambos no request \"2. Complete Activation with Password\"\n5. Execute para ativar conta com senha temporária validada via BCrypt\n6. Execute \"3. Login with New User\" com senha temporária para validar"
          },
          "response": []
        },
        {
          "name": "2. Complete Activation with Password",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 200\", function () {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"Response has usuarioId\", function () {",
                  "    const jsonData = pm.response.json();",
                  "    pm.expect(jsonData).to.have.property(\"usuarioId\");",
                  "    pm.expect(jsonData).to.have.property(\"email\");",
                  "    pm.expect(jsonData).to.have.property(\"tenantId\");",
                  "    pm.expect(jsonData).to.have.property(\"roles\");",
                  "});",
                  "",
                  "pm.test(\"Success message indicates immediate login\", function () {",
                  "    const jsonData = pm.response.json();",
                  "    pm.expect(jsonData.message).to.include(\"fazer login\");",
                  "});",
                  "",
                  "const jsonData = pm.response.json();",
                  "console.log(\"✅ Conta ativada COM SENHA TEMPORÁRIA (Option 2):\", jsonData.usuarioId);",
                  "console.log(\"   Email:\", jsonData.email);",
                  "console.log(\"   Tenant:\", jsonData.tenantId);",
                  "console.log(\"   Roles:\", jsonData.roles.join(\", \"));",
                  "console.log(\"   Mensagem:\", jsonData.message);",
                  "console.log(\"\");",
                  "console.log(\"🎉 Usuário pode fazer login com senha temporária!\");",
                  "console.log(\"   Execute o request '3. Login with New User' para testar\");",
                  "console.log(\"   ⚠️  Keycloak forçará troca de senha no primeiro login\");"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "auth": {
              "type": "noauth"
            },
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"token\": \"COLE-O-TOKEN-DO-EMAIL-AQUI\",\n  \"temporaryPassword\": \"COLE-A-SENHA-TEMPORARIA-DO-EMAIL-AQUI\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{api_url}}/v1/auth/complete-activation",
              "host": [
                "{{api_url}}"
              ],
              "path": [
                "v1",
                "auth",
                "complete-activation"
              ]
            },
            "description": "**Passo 2:** Completa ativação da conta com SENHA TEMPORÁRIA (Option 2 flow).\n\n**Endpoint PÚBLICO** - Não requer autenticação\n\n**Fluxo:**\n1. Usuário recebe email com: token + senha temporária (gerada pelo backend)\n2. Frontend exibe formulário: token + temporaryPassword\n3. Submit → POST /v1/auth/complete-activation\n4. Backend:\n   - Valida token (não expirado, status PENDING)\n   - Valida senha temporária contra hash BCrypt armazenado\n   - Cria usuario no PostgreSQL (email_verified=true)\n   - Cria membro no tenant\n   - Cria usuario no Keycloak com senha temporária + required action UPDATE_PASSWORD\n   - Marca convite como ACTIVATED\n5. Usuário faz primeiro login com senha temporária\n6. Keycloak FORÇA troca de senha (políticas gerenciadas pelo Keycloak)\n7. Usuário define senha permanente e está autenticado!\n\n**Body (Option 2):**\n```json\n{\n  \"token\": \"abc123xyz...\",\n  \"temporaryPassword\": \"Ab12#Xy9@Kl4\"\n}\n```\n\n**Validações:**\n- Token válido e não expirado (48h)\n- Token em status PENDING (não usado)\n- Senha temporária válida (match com hash BCrypt)\n- Email não duplicado\n\n**Para obter token e senha temporária:**\n1. Verifique arquivo em `/tmp/emails/` (último criado)\n2. Busque o token na URL e a senha temporária no corpo do email\n3. Cole ambos no body do request\n\n**Ou via SQL (apenas token):**\n```sql\nSELECT token FROM convite \nWHERE email = 'teste.fluxo.unico@example.com' \nAND status = 'PENDING' \nORDER BY created_at DESC LIMIT 1;\n```\n\n**Segurança Option 2:**\n- Backend gera senha temporária aleatória (12 chars)\n- Armazena apenas hash BCrypt no banco\n- Senha temporária enviada UMA VEZ no email\n- Keycloak força troca no primeiro login\n- Políticas de senha gerenciadas pelo Keycloak (comprimento, complexidade, histórico)"
          },
          "response": []
        },
        {
          "name": "3. Magic Link Activation (One-Click UX)",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 200\", function () {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"Response has usuarioId\", function () {",
                  "    const jsonData = pm.response.json();",
                  "    pm.expect(jsonData).to.have.property(\"usuarioId\");",
                  "    pm.expect(jsonData).to.have.property(\"email\");",
                  "    pm.expect(jsonData).to.have.property(\"tenantId\");",
                  "    pm.expect(jsonData).to.have.property(\"roles\");",
                  "});",
                  "",
                  "pm.test(\"Success message indicates immediate login\", function () {",
                  "    const jsonData = pm.response.json();",
                  "    pm.expect(jsonData.message).to.include(\"fazer login\");",
                  "});",
                  "",
                  "const jsonData = pm.response.json();",
                  "console.log(\"✅ Conta ativada VIA MAGIC LINK (One-Click):\", jsonData.usuarioId);",
                  "console.log(\"   Email:\", jsonData.email);",
                  "console.log(\"   Tenant:\", jsonData.tenantId);",
                  "console.log(\"   Roles:\", jsonData.roles.join(\", \"));",
                  "console.log(\"   Mensagem:\", jsonData.message);",
                  "console.log(\"\");",
                  "console.log(\"🎉 MAGIC LINK FUNCIONOU - Sem digitação de senha!\");",
                  "console.log(\"   Usuário pode fazer login com senha temporária\");",
                  "console.log(\"   Execute o request '4. Login with New User' para testar\");",
                  "console.log(\"   ⚠️  Keycloak forçará troca de senha no primeiro login\");"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "auth": {
              "type": "noauth"
            },
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"magicToken\": \"COLE-O-JWT-DO-EMAIL-AQUI\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{api_url}}/v1/auth/magic-activate",
              "host": [
                "{{api_url}}"
              ],
              "path": [
                "v1",
                "auth",
                "magic-activate"
              ]
            },
            "description": "**Passo 3 (Alternativa): Ativação via Magic Link JWT (UX melhorada - ONE CLICK!)**\n\n**Endpoint PÚBLICO** - Não requer autenticação\n\n**O que é Magic Link?**\nMagic Link é um JWT assinado que contém o token de convite + senha temporária criptografados. O usuário só precisa clicar no link do email - sem digitar nada!\n\n**Fluxo:**\n1. Usuário recebe email com magic link: `{{frontend_url}}/magic-activate?token=SIGNED_JWT`\n2. Usuário CLICA NO LINK (sem precisar digitar nada!)\n3. Frontend extrai JWT da URL e envia para este endpoint\n4. Backend:\n   - Valida assinatura do JWT (HMAC-SHA256)\n   - Valida expiração (48h)\n   - Extrai invitation token + senha temporária do JWT\n   - Chama o fluxo de ativação normal (mesmo que endpoint #2)\n5. Conta ativada! Usuário pode fazer login com senha temporária\n6. Keycloak força troca de senha no primeiro login\n\n**Body (Magic Link):**\n```json\n{\n  \"magicToken\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\"\n}\n```\n\n**JWT Claims (dentro do magicToken):**\n- `sub`: invitation token (string 40 chars)\n- `pwd`: senha temporária (plain text, criptografada no JWT)\n- `exp`: expiração (48 horas)\n- `iat`: issued at\n- `jti`: JWT ID único\n\n**Validações:**\n- JWT com assinatura válida (não foi adulterado)\n- JWT não expirado (48h)\n- Invitation token válido e não usado\n- Senha temporária válida (extraída do JWT)\n\n**Para obter o Magic Token:**\n1. Verifique arquivo em `/tmp/emails/` (último criado)\n2. Busque o JWT completo após \"magic-activate?token=\"\n3. Cole o JWT inteiro no campo `magicToken` do body\n\n**Segurança Magic Link:**\n- JWT assinado com HMAC-SHA256 (não pode ser forjado)\n- Senha temporária nunca armazenada em plain text no banco\n- JWT expira em 48h (mesma validade do convite)\n- Token só pode ser usado uma vez (convite é marcado como ACTIVATED)\n- Keycloak força troca de senha no primeiro login\n\n**Diferença entre Magic Link (#3) e Ativação Manual (#2):**\n- **#2 (Manual)**: Usuário digita token + senha temporária no formulário\n- **#3 (Magic Link)**: Usuário clica no link - ZERO digitação! ✨\n- Ambos ativam a conta da mesma forma, diferença é apenas UX\n\n**Vantagens Magic Link:**\n- ✅ UX perfeita: um clique ativa a conta\n- ✅ Menos erros: usuário não precisa copiar/colar nada\n- ✅ Mobile-friendly: funciona perfeitamente em smartphones\n- ✅ Segurança mantida: JWT assinado + senha temporária criptografada"
          },
          "response": []
        },
        {
          "name": "4. Login with New User",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 200\", function () {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"Response has access_token\", function () {",
                  "    const jsonData = pm.response.json();",
                  "    pm.expect(jsonData).to.have.property(\"access_token\");",
                  "    pm.expect(jsonData).to.have.property(\"refresh_token\");",
                  "    pm.expect(jsonData).to.have.property(\"id_token\");",
                  "});",
                  "",
                  "// Salva tokens",
                  "if (pm.response.code === 200) {",
                  "    const jsonData = pm.response.json();",
                  "    pm.environment.set(\"new_user_token\", jsonData.access_token);",
                  "    console.log(\"✅ LOGIN BEM-SUCEDIDO COM SENHA TEMPORÁRIA (Option 2)!\");",
                  "    console.log(\"   Access token obtido e salvo em 'new_user_token'\");",
                  "    console.log(\"   Token expira em:\", jsonData.expires_in, \"segundos\");",
                  "    console.log(\"\");",
                  "    console.log(\"🎉 FLUXO OPTION 2 COMPLETO!\");",
                  "    console.log(\"   ✓ Convite enviado com senha temporária aleatória\");",
                  "    console.log(\"   ✓ Conta ativada com senha temporária validada via BCrypt\");",
                  "    console.log(\"   ✓ Login com senha temporária funcionando\");",
                  "    console.log(\"   ⚠️  Keycloak forçará troca de senha no primeiro login (Authorization Code Flow)\");",
                  "} else {",
                  "    console.error(\"❌ Falha no login - verifique email/senha\");",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/x-www-form-urlencoded"
              }
            ],
            "body": {
              "mode": "urlencoded",
              "urlencoded": [
                {
                  "key": "grant_type",
                  "value": "password",
                  "type": "text"
                },
                {
                  "key": "client_id",
                  "value": "{{client_id}}",
                  "type": "text"
                },
                {
                  "key": "client_secret",
                  "value": "{{client_secret}}",
                  "type": "text"
                },
                {
                  "key": "username",
                  "value": "teste.fluxo.unico@example.com",
                  "type": "text",
                  "description": "Email do usuário convidado"
                },
                {
                  "key": "password",
                  "value": "SENHA-TEMPORARIA-DO-EMAIL",
                  "type": "text",
                  "description": "Senha temporária do email (gerada pelo backend no passo 1)"
                },
                {
                  "key": "scope",
                  "value": "openid profile email",
                  "type": "text"
                }
              ]
            },
            "url": {
              "raw": "{{keycloak_url}}/realms/{{keycloak_realm}}/protocol/openid-connect/token",
              "host": [
                "{{keycloak_url}}"
              ],
              "path": [
                "realms",
                "{{keycloak_realm}}",
                "protocol",
                "openid-connect",
                "token"
              ]
            },
            "description": "**Passo 3:** Faz login com o usuário recém-criado (Option 2: primeiro login com senha temporária).\n\n**IMPORTANTE - Fluxo Option 2:**\n- Este teste simula o primeiro login do usuário com senha temporária\n- **Keycloak FORÇARÁ troca de senha** (required action UPDATE_PASSWORD)\n- Em ambiente real, Keycloak redirecionará para tela de alteração de senha\n- Após troca, usuário terá senha permanente conhecida apenas por ele\n\n**Credenciais:**\n- username: `teste.fluxo.unico@example.com`\n- password: **senha temporária do email** (ex: `Ab12#Xy9@Kl4`)\n\n**O que este teste valida:**\n1. Usuário foi criado corretamente no Keycloak\n2. Senha temporária foi definida e é funcional\n3. Email foi marcado como verificado\n4. Required action UPDATE_PASSWORD está ativo\n5. Login com senha temporária funciona\n\n**Nota:** \n- Neste teste via Postman, o login via Resource Owner Password Credentials pode não enforcar o UPDATE_PASSWORD\n- Em aplicação real (Authorization Code Flow), Keycloak força troca de senha após login\n- Políticas de senha (comprimento, complexidade, histórico) são gerenciadas pelo Keycloak\n\n**Se falhar:**\n- Verifique se o passo 2 retornou 200\n- Use a senha temporária do email (não a senha permanente)\n- Cheque logs do backend em /tmp/backend-*.log"
          },
          "response": []
        }
      ]
    },
    {
      "name": "Tenant Members",
      "description": "Endpoints para gerenciamento de membros do tenant.\n\n**Funcionalidades:**\n- Listar membros ativos/inativos\n- Ver informações de limite do plano\n- Desativar membros (soft delete)\n\n**Requer:** ADMIN_TENANT ou GERENTE role",
      "item": [
        {
          "name": "List Tenant Members",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 200\", function () {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"Response has members array\", function () {",
                  "    const jsonData = pm.response.json();",
                  "    pm.expect(jsonData).to.have.property(\"members\");",
                  "    pm.expect(jsonData.members).to.be.an(\"array\");",
                  "});",
                  "",
                  "pm.test(\"Response has plan limit info\", function () {",
                  "    const jsonData = pm.response.json();",
                  "    pm.expect(jsonData).to.have.property(\"planLimit\");",
                  "    pm.expect(jsonData.planLimit).to.have.property(\"maxUsuarios\");",
                  "    pm.expect(jsonData.planLimit).to.have.property(\"currentActive\");",
                  "    pm.expect(jsonData.planLimit).to.have.property(\"available\");",
                  "});",
                  "",
                  "const jsonData = pm.response.json();",
                  "console.log(\"✅ Members loaded:\", jsonData.totalCount);",
                  "console.log(\"   Active:\", jsonData.activeCount);",
                  "console.log(\"   Inactive:\", jsonData.inactiveCount);",
                  "console.log(\"   Plan limit:\", jsonData.planLimit.currentActive + \"/\" + jsonData.planLimit.maxUsuarios);"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "auth": {
              "type": "bearer",
              "bearer": [
                {
                  "key": "token",
                  "value": "{{access_token}}",
                  "type": "string"
                }
              ]
            },
            "method": "GET",
            "header": [
              {
                "key": "X-Tenant-Id",
                "value": "{{tenant_id}}",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{api_url}}/v1/tenants/{{tenant_id}}/members?includeInactive=false",
              "host": [
                "{{api_url}}"
              ],
              "path": [
                "v1",
                "tenants",
                "{{tenant_id}}",
                "members"
              ],
              "query": [
                {
                  "key": "includeInactive",
                  "value": "false",
                  "description": "Incluir membros inativos (default: false)"
                }
              ]
            },
            "description": "Lista todos os membros do tenant com informações de limite do plano.\n\n**Requer:** ADMIN_TENANT ou GERENTE role\n\n**Query Parameters:**\n- `includeInactive`: boolean (default: false) - Incluir membros inativos\n\n**Response:**\n```json\n{\n  \"members\": [\n    {\n      \"usuarioId\": \"uuid\",\n      \"email\": \"user@example.com\",\n      \"nome\": \"Nome do Usuário\",\n      \"papeis\": [\"GERENTE\", \"OPERADOR\"],\n      \"ativo\": true,\n      \"joinedAt\": \"2025-01-15T10:30:00Z\",\n      \"lastUpdated\": \"2025-01-15T10:30:00Z\"\n    }\n  ],\n  \"totalCount\": 10,\n  \"activeCount\": 8,\n  \"inactiveCount\": 2,\n  \"planLimit\": {\n    \"maxUsuarios\": 10,\n    \"currentActive\": 8,\n    \"available\": 2,\n    \"limitReached\": false\n  }\n}\n```"
          },
          "response": []
        },
        {
          "name": "Deactivate Member",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 200\", function () {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"Response indicates success\", function () {",
                  "    const jsonData = pm.response.json();",
                  "    pm.expect(jsonData.success).to.be.true;",
                  "    pm.expect(jsonData.message).to.include(\"desativado com sucesso\");",
                  "});",
                  "",
                  "const jsonData = pm.response.json();",
                  "console.log(\"✅ Member deactivated:\", jsonData.usuarioId);",
                  "console.log(\"   Email:\", jsonData.email);",
                  "console.log(\"   Tenant:\", jsonData.tenantId);"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "auth": {
              "type": "bearer",
              "bearer": [
                {
                  "key": "token",
                  "value": "{{access_token}}",
                  "type": "string"
                }
              ]
            },
            "method": "DELETE",
            "header": [
              {
                "key": "X-Tenant-Id",
                "value": "{{tenant_id}}",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{api_url}}/v1/tenants/{{tenant_id}}/members/{{usuario_id_to_deactivate}}",
              "host": [
                "{{api_url}}"
              ],
              "path": [
                "v1",
                "tenants",
                "{{tenant_id}}",
                "members",
                "{{usuario_id_to_deactivate}}"
              ]
            },
            "description": "Desativa um membro do tenant (soft delete).\n\n**Requer:** ADMIN_TENANT ou GERENTE role\n\n**Validações:**\n- Membro deve existir e estar ativo\n- Não pode desativar o último ADMIN_TENANT do tenant\n\n**Path Parameters:**\n- `tenantId`: UUID do tenant\n- `usuarioId`: UUID do usuário a desativar\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"message\": \"Membro desativado com sucesso\",\n  \"usuarioId\": \"uuid\",\n  \"email\": \"user@example.com\",\n  \"tenantId\": \"uuid\"\n}\n```\n\n**Errors:**\n- 404: Membro não encontrado\n- 400: Membro já está inativo\n- 400: Não é possível desativar o último ADMIN_TENANT\n\n**Exemplo:**\n1. Execute \"List Tenant Members\" para ver membros\n2. Copie o `usuarioId` de um membro de teste\n3. Crie variável `usuario_id_to_deactivate` com esse UUID\n4. Execute este endpoint"
          },
          "response": []
        }
      ]
    },
    {
      "name": "Auth Tests",
      "description": "Endpoints de teste para validação de segurança (RBAC, OPA, multi-tenancy)\n\n⚠️ **IMPORTANTE**: Estes endpoints são apenas para testes e devem ser removidos em produção.",
      "item": [
        {
          "name": "Public Endpoint",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 200\", function () {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"Response has message\", function () {",
                  "    const jsonData = pm.response.json();",
                  "    pm.expect(jsonData).to.have.property(\"message\");",
                  "    pm.expect(jsonData.message).to.include(\"Public endpoint\");",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "auth": {
              "type": "noauth"
            },
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{api_url}}/v1/auth-test/public",
              "host": [
                "{{api_url}}"
              ],
              "path": [
                "v1",
                "auth-test",
                "public"
              ]
            },
            "description": "Endpoint público sem autenticação.\n\nUse para testar conectividade com a API."
          },
          "response": []
        },
        {
          "name": "Get Current User (Me)",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 200\", function () {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"Response has authenticated=true\", function () {",
                  "    const jsonData = pm.response.json();",
                  "    pm.expect(jsonData.authenticated).to.be.true;",
                  "});",
                  "",
                  "pm.test(\"Response has JWT claims\", function () {",
                  "    const jsonData = pm.response.json();",
                  "    pm.expect(jsonData).to.have.property(\"jwt\");",
                  "    pm.expect(jsonData.jwt).to.have.property(\"sub\");",
                  "    pm.expect(jsonData.jwt).to.have.property(\"email\");",
                  "});",
                  "",
                  "pm.test(\"Response has tenantId\", function () {",
                  "    const jsonData = pm.response.json();",
                  "    pm.expect(jsonData).to.have.property(\"tenantId\");",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "auth": {
              "type": "bearer",
              "bearer": [
                {
                  "key": "token",
                  "value": "{{access_token}}",
                  "type": "string"
                }
              ]
            },
            "method": "GET",
            "header": [
              {
                "key": "X-Tenant-Id",
                "value": "{{tenant_id}}",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{api_url}}/v1/auth-test/me",
              "host": [
                "{{api_url}}"
              ],
              "path": [
                "v1",
                "auth-test",
                "me"
              ]
            },
            "description": "Retorna informações do usuário autenticado extraídas do JWT.\n\n**Valida:**\n- Extração de claims do JWT (sub, email, roles, tenant_id)\n- Validação de tenant_id vs header X-Tenant-Id\n- Authorities (roles) do Spring Security"
          },
          "response": []
        },
        {
          "name": "Operador Only",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "// Se o usuário tem role OPERADOR, deve retornar 200",
                  "// Caso contrário, deve retornar 403 Forbidden",
                  "",
                  "if (pm.response.code === 200) {",
                  "    pm.test(\"User has OPERADOR role - Access granted\", function () {",
                  "        const jsonData = pm.response.json();",
                  "        pm.expect(jsonData.message).to.include(\"OPERADOR\");",
                  "    });",
                  "} else if (pm.response.code === 403) {",
                  "    pm.test(\"User does NOT have OPERADOR role - Access denied (expected)\", function () {",
                  "        pm.expect(pm.response.code).to.equal(403);",
                  "    });",
                  "} else {",
                  "    pm.test(\"Unexpected status code\", function () {",
                  "        pm.expect.fail(\"Expected 200 or 403, got \" + pm.response.code);",
                  "    });",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "auth": {
              "type": "bearer",
              "bearer": [
                {
                  "key": "token",
                  "value": "{{access_token}}",
                  "type": "string"
                }
              ]
            },
            "method": "GET",
            "header": [
              {
                "key": "X-Tenant-Id",
                "value": "{{tenant_id}}",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{api_url}}/v1/auth-test/operador-only",
              "host": [
                "{{api_url}}"
              ],
              "path": [
                "v1",
                "auth-test",
                "operador-only"
              ]
            },
            "description": "Endpoint protegido que requer role **OPERADOR**.\n\n**Valida:**\n- @PreAuthorize com single role\n- 403 Forbidden se usuário não tem a role"
          },
          "response": []
        },
        {
          "name": "Manager Only",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "if (pm.response.code === 200) {",
                  "    pm.test(\"User has GERENTE or ADMIN_TENANT role - Access granted\", function () {",
                  "        const jsonData = pm.response.json();",
                  "        pm.expect(jsonData.message).to.include(\"GERENTE\");",
                  "    });",
                  "} else if (pm.response.code === 403) {",
                  "    pm.test(\"User does NOT have required roles - Access denied (expected)\", function () {",
                  "        pm.expect(pm.response.code).to.equal(403);",
                  "    });",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "auth": {
              "type": "bearer",
              "bearer": [
                {
                  "key": "token",
                  "value": "{{access_token}}",
                  "type": "string"
                }
              ]
            },
            "method": "GET",
            "header": [
              {
                "key": "X-Tenant-Id",
                "value": "{{tenant_id}}",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{api_url}}/v1/auth-test/manager-only",
              "host": [
                "{{api_url}}"
              ],
              "path": [
                "v1",
                "auth-test",
                "manager-only"
              ]
            },
            "description": "Endpoint protegido que requer role **GERENTE** ou **ADMIN_TENANT**.\n\n**Valida:**\n- @PreAuthorize com múltiplas roles (hasAnyRole)"
          },
          "response": []
        },
        {
          "name": "Finance Only",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "if (pm.response.code === 200) {",
                  "    pm.test(\"User has FINANCEIRO role - Access granted\", function () {",
                  "        const jsonData = pm.response.json();",
                  "        pm.expect(jsonData.message).to.include(\"FINANCEIRO\");",
                  "    });",
                  "} else if (pm.response.code === 403) {",
                  "    pm.test(\"User does NOT have FINANCEIRO role - Access denied (expected)\", function () {",
                  "        pm.expect(pm.response.code).to.equal(403);",
                  "    });",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "auth": {
              "type": "bearer",
              "bearer": [
                {
                  "key": "token",
                  "value": "{{access_token}}",
                  "type": "string"
                }
              ]
            },
            "method": "GET",
            "header": [
              {
                "key": "X-Tenant-Id",
                "value": "{{tenant_id}}",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{api_url}}/v1/auth-test/finance-only",
              "host": [
                "{{api_url}}"
              ],
              "path": [
                "v1",
                "auth-test",
                "finance-only"
              ]
            },
            "description": "Endpoint protegido que requer role **FINANCEIRO**."
          },
          "response": []
        },
        {
          "name": "OPA RBAC Test",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 200\", function () {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"Response has decision\", function () {",
                  "    const jsonData = pm.response.json();",
                  "    pm.expect(jsonData).to.have.property(\"decision\");",
                  "    pm.expect(jsonData.decision).to.have.property(\"allow\");",
                  "    pm.expect(jsonData.decision).to.have.property(\"tenant_is_valid\");",
                  "});",
                  "",
                  "// Log resultado",
                  "const decision = pm.response.json().decision;",
                  "if (decision.allow) {",
                  "    console.log(\"✅ OPA RBAC: Access ALLOWED\");",
                  "} else {",
                  "    console.log(\"❌ OPA RBAC: Access DENIED\");",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "auth": {
              "type": "bearer",
              "bearer": [
                {
                  "key": "token",
                  "value": "{{access_token}}",
                  "type": "string"
                }
              ]
            },
            "method": "GET",
            "header": [
              {
                "key": "X-Tenant-Id",
                "value": "{{tenant_id}}",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{api_url}}/v1/auth-test/opa/rbac?action=locacao:checkin&role=OPERADOR",
              "host": [
                "{{api_url}}"
              ],
              "path": [
                "v1",
                "auth-test",
                "opa",
                "rbac"
              ],
              "query": [
                {
                  "key": "action",
                  "value": "locacao:checkin",
                  "description": "Ação a validar (ex: modelo:list, locacao:checkin)"
                },
                {
                  "key": "role",
                  "value": "OPERADOR",
                  "description": "Papel do usuário (ex: OPERADOR, GERENTE)"
                },
                {
                  "key": "resourceTenantId",
                  "value": "",
                  "description": "Tenant do recurso (opcional, usa tenantId do user se omitido)",
                  "disabled": true
                }
              ]
            },
            "description": "Testa autorização RBAC via OPA (Open Policy Agent).\n\n**Parâmetros:**\n- `action`: Ação a validar (ex: modelo:list, locacao:checkin)\n- `role`: Papel do usuário (ex: OPERADOR, GERENTE)\n- `resourceTenantId`: Tenant do recurso (opcional)\n\n**Exemplos de ações:**\n- `modelo:list` - Listar modelos\n- `locacao:checkin` - Check-in de locação\n- `locacao:checkout` - Check-out de locação\n- `os:criar` - Criar ordem de serviço"
          },
          "response": []
        },
        {
          "name": "OPA Alçada Test",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 200\", function () {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"Response has decision with alcada fields\", function () {",
                  "    const jsonData = pm.response.json();",
                  "    pm.expect(jsonData.decision).to.have.property(\"allow\");",
                  "    pm.expect(jsonData.decision).to.have.property(\"requer_aprovacao\");",
                  "});",
                  "",
                  "// Log resultado",
                  "const decision = pm.response.json().decision;",
                  "console.log(\"OPA Alçada:\");",
                  "console.log(\"  Allow:\", decision.allow);",
                  "console.log(\"  Requer Aprovação:\", decision.requer_aprovacao);",
                  "if (decision.aprovador_requerido !== \"N/A\") {",
                  "    console.log(\"  Aprovador Requerido:\", decision.aprovador_requerido);",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "auth": {
              "type": "bearer",
              "bearer": [
                {
                  "key": "token",
                  "value": "{{access_token}}",
                  "type": "string"
                }
              ]
            },
            "method": "GET",
            "header": [
              {
                "key": "X-Tenant-Id",
                "value": "{{tenant_id}}",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{api_url}}/v1/auth-test/opa/alcada?action=desconto:aplicar&role=OPERADOR&percentualDesconto=15",
              "host": [
                "{{api_url}}"
              ],
              "path": [
                "v1",
                "auth-test",
                "opa",
                "alcada"
              ],
              "query": [
                {
                  "key": "action",
                  "value": "desconto:aplicar",
                  "description": "Ação (ex: desconto:aplicar, os:aprovar)"
                },
                {
                  "key": "role",
                  "value": "OPERADOR",
                  "description": "Papel do usuário"
                },
                {
                  "key": "percentualDesconto",
                  "value": "15",
                  "description": "Percentual de desconto (para desconto:aplicar)"
                },
                {
                  "key": "valorOs",
                  "value": "",
                  "description": "Valor da OS (para os:aprovar)",
                  "disabled": true
                }
              ]
            },
            "description": "Testa política de Alçada (autoridade de aprovação) via OPA.\n\n**Casos de uso:**\n- Aplicar desconto: Valida se usuário pode aplicar X% de desconto\n- Aprovar OS: Valida se usuário pode aprovar OS de R$ X\n\n**Parâmetros:**\n- `action`: desconto:aplicar ou os:aprovar\n- `role`: Papel do usuário\n- `percentualDesconto`: % de desconto (para desconto:aplicar)\n- `valorOs`: Valor da OS em reais (para os:aprovar)\n\n**Exemplos:**\n1. OPERADOR aplicar 10% desconto → allow=true\n2. OPERADOR aplicar 25% desconto → allow=false, requer_aprovacao=true, aprovador=GERENTE\n3. GERENTE aprovar OS de R$ 5.000 → allow=true\n4. GERENTE aprovar OS de R$ 15.000 → allow=false, requer_aprovacao=true, aprovador=ADMIN_TENANT"
          },
          "response": []
        },
        {
          "name": "OPA Generic Authorize",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 200\", function () {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"Response has decision\", function () {",
                  "    const jsonData = pm.response.json();",
                  "    pm.expect(jsonData).to.have.property(\"decision\");",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "auth": {
              "type": "bearer",
              "bearer": [
                {
                  "key": "token",
                  "value": "{{access_token}}",
                  "type": "string"
                }
              ]
            },
            "method": "POST",
            "header": [
              {
                "key": "X-Tenant-Id",
                "value": "{{tenant_id}}",
                "type": "text"
              },
              {
                "key": "Content-Type",
                "value": "application/json",
                "type": "text"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"action\": \"locacao:checkin\",\n  \"user\": {\n    \"id\": \"550e8400-e29b-41d4-a716-446655440000\",\n    \"tenant_id\": \"{{tenant_id}}\",\n    \"role\": \"OPERADOR\"\n  },\n  \"resource\": {\n    \"id\": \"123e4567-e89b-12d3-a456-426614174000\",\n    \"tenant_id\": \"{{tenant_id}}\"\n  },\n  \"operation\": {\n    \"percentual_desconto\": null,\n    \"valor_os\": null\n  }\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{api_url}}/v1/auth-test/opa/authorize",
              "host": [
                "{{api_url}}"
              ],
              "path": [
                "v1",
                "auth-test",
                "opa",
                "authorize"
              ]
            },
            "description": "Testa autorização genérica (RBAC + Alçada) via OPA.\n\nEste endpoint combina:\n1. Validação RBAC (role tem permissão?)\n2. Se sim e há contexto de operação, valida Alçada\n\n**Body:**\n```json\n{\n  \"action\": \"locacao:checkin\",\n  \"user\": {\n    \"id\": \"user-uuid\",\n    \"tenant_id\": \"tenant-uuid\",\n    \"role\": \"OPERADOR\"\n  },\n  \"resource\": {\n    \"id\": \"resource-uuid\",\n    \"tenant_id\": \"tenant-uuid\"\n  },\n  \"operation\": {\n    \"percentual_desconto\": 10,\n    \"valor_os\": 5000.00\n  }\n}\n```"
          },
          "response": []
        }
      ]
    },
    {
      "name": "Health",
      "description": "Health checks e métricas de observabilidade",
      "item": [
        {
          "name": "Health Check",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 200\", function () {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"Status is UP\", function () {",
                  "    const jsonData = pm.response.json();",
                  "    pm.expect(jsonData.status).to.equal(\"UP\");",
                  "});",
                  "",
                  "pm.test(\"Has components\", function () {",
                  "    const jsonData = pm.response.json();",
                  "    pm.expect(jsonData).to.have.property(\"components\");",
                  "});",
                  "",
                  "// Verifica se PostgreSQL está UP",
                  "const components = pm.response.json().components;",
                  "if (components.db) {",
                  "    pm.test(\"Database is UP\", function () {",
                  "        pm.expect(components.db.status).to.equal(\"UP\");",
                  "    });",
                  "}",
                  "",
                  "// Verifica se Redis está UP (se configurado)",
                  "if (components.redis) {",
                  "    pm.test(\"Redis is UP\", function () {",
                  "        pm.expect(components.redis.status).to.equal(\"UP\");",
                  "    });",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "auth": {
              "type": "noauth"
            },
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{api_url}}/actuator/health",
              "host": [
                "{{api_url}}"
              ],
              "path": [
                "actuator",
                "health"
              ]
            },
            "description": "Health check da aplicação.\n\nRetorna status da aplicação e seus componentes (database, redis, etc.)."
          },
          "response": []
        },
        {
          "name": "Metrics",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test(\"Status code is 200\", function () {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test(\"Has metrics\", function () {",
                  "    const jsonData = pm.response.json();",
                  "    pm.expect(jsonData).to.have.property(\"names\");",
                  "    pm.expect(jsonData.names).to.be.an(\"array\");",
                  "    pm.expect(jsonData.names.length).to.be.greaterThan(0);",
                  "});"
                ],
                "type": "text/javascript"
              }
            }
          ],
          "request": {
            "auth": {
              "type": "noauth"
            },
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{api_url}}/actuator/metrics",
              "host": [
                "{{api_url}}"
              ],
              "path": [
                "actuator",
                "metrics"
              ]
            },
            "description": "Lista todas as métricas disponíveis.\n\nPara ver detalhes de uma métrica específica:\n`GET /actuator/metrics/{metric.name}`\n\nExemplos:\n- `/actuator/metrics/jvm.memory.used`\n- `/actuator/metrics/http.server.requests`"
          },
          "response": []
        },
        {
          "name": "Prometheus Metrics",
          "request": {
            "auth": {
              "type": "noauth"
            },
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{api_url}}/actuator/prometheus",
              "host": [
                "{{api_url}}"
              ],
              "path": [
                "actuator",
                "prometheus"
              ]
            },
            "description": "Endpoint de métricas no formato Prometheus.\n\nUse para integração com Prometheus/Grafana."
          },
          "response": []
        }
      ]
    }
  ],
  "event": [
    {
      "listen": "prerequest",
      "script": {
        "type": "text/javascript",
        "exec": [
          "// Script global executado antes de cada request",
          "// Valida se as variáveis essenciais estão configuradas",
          "",
          "const currentRequest = pm.request;",
          "const authType = currentRequest.auth ? currentRequest.auth.type : 'noauth';",
          "",
          "// Se o request requer autenticação, valida token",
          "if (authType === 'bearer') {",
          "    const token = pm.environment.get('access_token');",
          "    if (!token) {",
          "        console.warn('⚠️  Token não encontrado. Execute \"Get Access Token\" primeiro.');",
          "    }",
          "}",
          "",
          "// Log do request sendo executado",
          "console.log('🚀 Executando:', pm.request.name);"
        ]
      }
    },
    {
      "listen": "test",
      "script": {
        "type": "text/javascript",
        "exec": [
          "// Script global executado após cada response",
          "",
          "// Log do resultado",
          "const statusCode = pm.response.code;",
          "const responseTime = pm.response.responseTime;",
          "",
          "if (statusCode >= 200 && statusCode < 300) {",
          "    console.log('✅ Success:', statusCode, '| Response time:', responseTime + 'ms');",
          "} else if (statusCode >= 400 && statusCode < 500) {",
          "    console.warn('⚠️  Client error:', statusCode, '| Response time:', responseTime + 'ms');",
          "} else if (statusCode >= 500) {",
          "    console.error('❌ Server error:', statusCode, '| Response time:', responseTime + 'ms');",
          "}",
          "",
          "// Valida tempo de resposta",
          "pm.test('Response time is acceptable (< 5000ms)', function () {",
          "    pm.expect(responseTime).to.be.below(5000);",
          "});"
        ]
      }
    }
  ],
  "variable": [
    {
      "key": "collection_version",
      "value": "1.2.1",
      "type": "string",
      "description": "Infrastructure update: OPA v1.9.0 with Rego v1 policies (2025-10-20)"
    }
  ]
}
